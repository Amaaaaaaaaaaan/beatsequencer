<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="x-ua-compatible" content="ie=edge" />
  <meta name="description" itemprop="description" content="Beatboxer is a drum machine in about 100 lines of html/js/css" />
  <meta itemprop="name" content="Beatboxer" />
  <meta itemprop="image" content="http://sig.gy/beatboxer/thumbnail.png" />

  <title>Beatboxer</title>

  <style>
  /* Light mode styles */
body.light-mode {
  background-color: white;
  color: black;
  transition: background-color 0.3s ease, color 0.3s ease;  /* Smooth transition for background and text color */
}

/* Dark mode styles (default) */
body {
  background-color: black;
  color: white;
  transition: background-color 0.3s ease, color 0.3s ease;  /* Smooth transition for background and text color */
}

/* Toggle button styles */
#modeToggle {
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 15px;
  background-color: gray;
  border-radius: 50%;
  cursor: pointer;
  color: white;
  font-size: 16px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
  transition: background-color 0.3s ease, transform 0.3s ease;  /* Smooth transition for background color and transform */
}

/* Toggle button hover effect */
#modeToggle:hover {
  background-color: #4b4b4b;
  transform: scale(1.1);  /* Button grows slightly when hovered */
}

/* Button active state (when clicked) */
#modeToggle:active {
  transform: scale(0.95);  /* Slight shrink when clicked */
}

/* Styling for the beat buttons */
button.beat {
  background-color: black;
  padding: 10px;
  border: 10px solid white;
  margin: 5px;
  cursor: pointer;
  width: 0;
  height: 0;
  transition: background-color 0.2s ease, border-color 0.2s ease;  /* Smooth transition for beat buttons */
}

/* Active state of the beat button */
button.on {
  background-color: red;
  border-color: red;
}

/* Ticked state of the beat button */
button.ticked {
  background-color: white;
  border-color: white;
}

/* Grid styling */
#grid {
  width: 800px;
  height: 200px;
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  margin: auto;
}


    .github-corner:hover .octo-arm {
      animation: octocat-wave 560ms ease-in-out;
    }

    @keyframes octocat-wave {
      0%, 100% {
        transform: rotate(0);
      }
      20%, 60% {
        transform: rotate(-25deg);
      }
      40%, 80% {
        transform: rotate(10deg);
      }
    }

    @media (max-width: 500px) {
      .github-corner:hover .octo-arm {
        animation: none;
      }

      .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out;
      }
    }
  </style>
</head>
<body>
  <div id="grid"></div>
  <!-- Control buttons -->
  <button id="startRecordingButton">Start Recording</button>
  <button id="stopRecordingButton">Stop Recording</button>
  <button id="stopSequencerButton">Stop Sequencer</button>
  <button id="startSequencerButton">Start Sequencer</button> <!-- Start button for the sequencer -->
  <!-- Link to download the recorded audio -->
<!-- Mode Toggle Button -->
<button id="modeToggle">ðŸŒ™</button>

  <a id="downloadLink" style="display: none;">Download Recording</a>

  <script>
    const BPM = 120;
    const TICKS = 16;
    const INTERVAL = 1 / (4 * BPM / (60 * 1000));
    const MAX_BITS = 32;
    const MAX_HEX = MAX_BITS / 4;

    const sounds = [
      'sounds/bass_drum.wav',
      'sounds/snare_drum.wav',
      'sounds/low_tom.wav',
      'sounds/mid_tom.wav',
    ];
    document.getElementById('modeToggle').addEventListener('click', () => {
        document.body.classList.toggle('light-mode');
    });
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const buffers = [];
    const theGrid = document.getElementById('grid');
    const sLen = sounds.length;
    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;
    let recordingSourceNode;
    let recordingDestination;
    let lastTick = TICKS - 1;
    let curTick = 0;
    let lastTime = new Date().getTime();
    let isRunning = true;  // Flag to control if the loop is running
    let savedHash = '';  // Variable to save the state of the grid

    function binToHex(bin) {
      let hex = '';
      for (let i = 0, len = bin.length; i < len; i += MAX_BITS) {
        let tmp = parseInt(bin.substr(i, MAX_BITS), 2).toString(16);
        while (tmp.length < MAX_HEX) {
          tmp = '0' + tmp;
        }
        hex += tmp;
      }
      return hex;
    }

    function hexToBin(hex) {
      let bin = '';
      for (let i = 0, len = hex.length; i < len; i += MAX_HEX) {
        let tmp = parseInt(hex.substr(i, MAX_HEX), 16).toString(2);
        while (tmp.length < MAX_BITS) {
          tmp = '0' + tmp;
        }
        bin += tmp;
      }
      return bin;
    }

    function updateState() {
      let state = '';
      Array.from(beats).map(function (btn) {
        state += btn.classList.contains('on') ? '1' : '0';
      });
      window.location.hash = binToHex(state);
    }

    function restoreState() {
      let hash = savedHash || window.location.hash;
      hash = (hash === '') ? '0000000000000000' : hash.substr(1);
      hexToBin(hash).split('').map(function (el, i) {
        if (parseInt(el) === 1) {
          beats[i].classList.add('on');
        } else {
          beats[i].classList.remove('on');
        }
      });
    }

    window.addEventListener('hashchange', restoreState, false);

    for (let soundIndex = 0; soundIndex < sLen; ++soundIndex) {
      (function (index) {
        const req = new XMLHttpRequest();
        req.open('GET', sounds[index], true);
        req.responseType = 'arraybuffer';
        req.onload = function () {
          audioCtx.decodeAudioData(req.response, function (buffer) {
            buffers.push(buffer);
          });
        };
        req.send();
      })(soundIndex);

      const fragment = document.createDocumentFragment();
      for (let t = 0; t < TICKS; ++t) {
        const btn = document.createElement('button');
        btn.className = 'beat';
        btn.addEventListener('click', function () {
          this.classList.toggle('on');
          updateState();
        }, false);
        fragment.appendChild(btn);
      }
      theGrid.appendChild(fragment);
      theGrid.appendChild(document.createElement('p'));
    }

    const beats = document.getElementsByClassName('beat');

    function drumLoop() {
      if (!isRunning) return;  // If not running, exit the loop early

      const curTime = new Date().getTime();
      if (curTime - lastTime >= INTERVAL) {
        for (let i = 0; i < sLen; ++i) {
          const lastBeat = beats[i * TICKS + lastTick];
          const curBeat = beats[i * TICKS + curTick];
          lastBeat.classList.remove('ticked');
          curBeat.classList.add('ticked');

          if (curBeat.classList.contains('on')) {
            try {
              const source = audioCtx.createBufferSource();
              source.buffer = buffers[i];
              source.connect(audioCtx.destination);
              source.start();

              if (isRecording) {
                source.connect(recordingDestination);
              }
            } catch (e) {
              console.error(e.message);
              new Audio(sounds[i]).play();
            }
          }
        }
        lastTick = curTick;
        curTick = (curTick + 1) % TICKS;
        lastTime = curTime;
      }
      if (isRunning) {
        requestAnimationFrame(drumLoop);  // Continue the loop only if running
      }
    }

    restoreState();
    requestAnimationFrame(drumLoop);

    function enableIOSAudio() {
      const buffer = audioCtx.createBuffer(1, 1, 22050);
      const source = audioCtx.createBufferSource();
      source.buffer = buffer;
      source.connect(audioCtx.destination);
      source.start(0); // Use 'start' instead of 'noteOn'
      window.removeEventListener('touchend', enableIOSAudio, false);
    }

    window.addEventListener('touchend', enableIOSAudio, false);

    // Recording functionality
    function startRecording() {
      isRecording = true;
      audioChunks = [];
      recordingSourceNode = audioCtx.createGain();
      recordingDestination = audioCtx.createMediaStreamDestination();
      recordingSourceNode.connect(recordingDestination);
      mediaRecorder = new MediaRecorder(recordingDestination.stream);
      mediaRecorder.ondataavailable = function (event) {
        audioChunks.push(event.data);
      };
      mediaRecorder.onstop = function () {
        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
        const audioURL = URL.createObjectURL(audioBlob);
        const downloadLink = document.getElementById('downloadLink');
        downloadLink.href = audioURL;
        downloadLink.download = 'recording.wav';
        downloadLink.style.display = 'block';
      };
      mediaRecorder.start();
    }

    function stopRecording() {
      isRecording = false;
      mediaRecorder.stop();
    }

    // Stop sequencer function
    function stopSequencer() {
      isRunning = false;  // Stop the loop
      console.log("Sequencer stopped");

      // Save current state to the savedHash variable
      let state = '';
      Array.from(beats).map(function (btn) {
        state += btn.classList.contains('on') ? '1' : '0';
      });
      savedHash = binToHex(state);  // Save the state

      // Reset all beats to off state
      Array.from(beats).forEach((btn) => {
        btn.classList.remove('on', 'ticked');  // Remove 'on' and 'ticked' classes
      });

      // Optionally disable the stop button
      document.getElementById('stopSequencerButton').disabled = true;
    }

    // Reset the sequencer and start again
    function startSequencer() {
      isRunning = true;  // Start the loop
      restoreState();  // Restore the saved state
      requestAnimationFrame(drumLoop);  // Start the loop again

      // Enable the stop button
      document.getElementById('stopSequencerButton').disabled = false;
    }

    // Event listeners for buttons
    document.getElementById('startRecordingButton').addEventListener('click', startRecording);
    document.getElementById('stopRecordingButton').addEventListener('click', stopRecording);
    document.getElementById('stopSequencerButton').addEventListener('click', stopSequencer);

    // Optionally, you could create a start button for the sequencer
    document.getElementById('startSequencerButton').addEventListener('click', startSequencer);
  </script>
</body>
</html>
